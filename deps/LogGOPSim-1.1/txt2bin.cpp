/* Generated by re2c 3.0 on Sun Jul  9 14:40:56 2023 */
#line 1 "txt2bin.re"
#include <map>
#include <math.h>
#include <string>
#include <limits>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/types.h>

#include "Goal.hpp"
#include "cmdline_txt2bin.h"

typedef unsigned int uint;
typedef unsigned char uchar;

#define	BSIZE	10240

#define	YYCTYPE		uchar
#define	YYCURSOR	cursor
#define	YYLIMIT		s->lim
#define	YYMARKER	s->ptr
#define	YYFILL(n)	{cursor = fill(s, cursor, n);}

#define	RET(i)	{s->cur = cursor; return i;}

gengetopt_args_info args_info;

typedef struct Scanner {
    FILE*		fd;
    uchar		*bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
    uint		line;
	int			rank;
	uint32_t 	curr_rank, num_ranks;
	Goal*		schedule;
	std::map<std::string, goalop_t>* idtbl;
} Scanner;

typedef struct Item {
	char type;
	char *label1;
	char *label2;
	uint64_t size;
	uint32_t target;
	uint32_t tag;
	uint8_t cpu;
	uint8_t nic;	
} Item;

enum OpTypes {
	Undefined,
	SendOp,
	RecvOp,
	LoclOp,
	StartDependency,
	Dependency
};

inline uint64_t add_number(unsigned char *s, unsigned char *e) {

	uint64_t num = 0;	
	--s;
	while(++s < e) num = num * 10 + (*s - '0');

	return num;
}

inline void insert_id(Scanner *s, char *id, goalop_t op) {

	s->idtbl->insert(std::make_pair(std::string(id), op));
	free(id);
}

inline goalop_t retrieve_id(Scanner *s, char *id) {

	std::map<std::string, goalop_t>::iterator it;
	it = s->idtbl->find(std::string(id));
	if (it == s->idtbl->end()) {
		fprintf(stderr, "A dependency references label %s, which is undefined!\n", id);
		exit(EXIT_FAILURE);
	}
	free(id);
	return it->second;
} 

void process_item(Scanner *s, Item *item) {

/*
	printf("Parsed Item:\n");
	printf("  Type: ");
	if (item->type == Undefined) printf("Undefined\n");
	if (item->type == SendOp) printf("Send\n");
	if (item->type == RecvOp) printf("Recv\n");
	if (item->type == LoclOp) printf("LoclOp\n");
	if (item->type == StartDependency) printf("IRequires\n");
	if (item->type == Dependency) printf("Requires\n");
	printf("  Label1: %s\n", item->label1);
	printf("  Label2: %s\n", item->label2);
	printf("  Size: %i\n", item->size);
	printf("  Target: %i\n", item->target);
	printf("  Tag: %i\n", item->tag);
	printf("  CPU: %i\n", item->cpu);
	printf("  NIC: %i\n", item->nic);
*/
	
	goalop_t op, op2;

	switch (item->type) {
		case Undefined:
			fprintf(stderr, "Error while parsing, attempt to add a undefined operation\n");
			exit(EXIT_FAILURE);
			break;
		case SendOp:
			op = s->schedule->Send(s->rank, item->target, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case RecvOp:
			op = s->schedule->Recv(item->target, s->rank, item->size, item->tag, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case LoclOp:
			op = s->schedule->Calc(s->rank, item->size, item->cpu, item->nic);
			if (item->label1 != NULL) insert_id(s, item->label1, op);
			break;
		case StartDependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->StartDependency(op, op2);
			break;
		case Dependency:
			op = retrieve_id(s, item->label1);
			op2 = retrieve_id(s, item->label2);
			assert(op != NULL);
			assert(op2 != NULL);
			s->schedule->Dependency(op, op2);
			break;
		default:
			break;
	}
}

inline char* add_label(unsigned char *s, unsigned char *e) {
	
	char *buf = NULL;

	buf = (char *) malloc((e-s)+1);
	memcpy((void *) buf, (void *) s, (size_t) (e-s));
	buf[e-s] = '\0';
	
	return buf;

}


uchar *fill(Scanner *s, uchar *cursor, int numtoread) {

	if(!s->eof) {
		uint cnt = s->tok - s->bot;
		if(cnt){
			if ((s->lim - s->tok) < abs(s->bot - s->tok)) memcpy(s->bot, s->tok, s->lim - s->tok);
			else memmove(s->bot, s->tok, s->lim - s->tok);
			s->tok = s->bot;
			s->ptr -= cnt;
			cursor -= cnt;
			s->pos -= cnt;
			s->lim -= cnt;
		}
		if((s->top - s->lim) < BSIZE){
			uchar *buf = (uchar*) malloc(((s->lim - s->bot) + BSIZE)*sizeof(uchar));
			if ((s->lim - s->tok) > abs(s->tok - buf)) memmove(buf, s->tok, s->lim - s->tok);
			else memcpy(buf, s->tok, s->lim - s->tok);
			s->tok = buf;
			s->ptr = &buf[s->ptr - s->bot];
			cursor = &buf[cursor - s->bot];
			s->pos = &buf[s->pos - s->bot];
			s->lim = &buf[s->lim - s->bot];
			s->top = &s->lim[BSIZE];
			free(s->bot);
			s->bot = buf;
		}
		cnt = fread((char*) s->lim, 1, BSIZE, s->fd);
		if(cnt != BSIZE) { 
			s->eof = &s->lim[cnt];
			*(s->eof)++ = '\n';
		}
		s->lim += cnt;
		//assert(cnt >= numtoread);
	}
	return cursor;
}

/*
uchar *fill(Scanner *s, uchar *cursor, int numtoread) {
	
	static bool firstcall = true;

	if (firstcall) {
		
		void *buf;
		struct stat statbuf;
		
		int ret = fstat(fileno(s->fd), &statbuf);
		buf = mmap(NULL, statbuf.st_size, PROT_READ, MAP_PRIVATE, fileno(s->fd), 0);
		assert(buf != NULL);
		s->lim = (uchar*) buf;
		s->lim += statbuf.st_size;
		s->eof = s->lim;
		return (uchar*) buf;	   		
	}
	else {
		assert(0==1);
	}
}
*/

int scan(Scanner *s) {

	//uchar *cursor = s->cur;

	static uchar *cursor = NULL;
	Item item;
	int state;

	for (;;) {

s_0:

	if ((cursor == s->eof) and (cursor != NULL)) {
		fprintf(stderr, "Reached the end of the inputfile - did you forget a closing bracket?\n");
		return s->rank;
	}
	
	s->tok = cursor;
	state = 0;
	
	// printf("Entered s_0\n");
	// if (((s->line % 100) == 0) or (s->line < 100)) printf("Line: %i\n", s->line);

	item.type = Undefined;
	item.label1 = NULL;
	item.label2 = NULL;
	item.cpu = 0;
	item.nic = 0;
	item.tag = 0;


#line 256 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 10) YYFILL(10);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy3;
				case '\n': goto yy5;
				case '\r': goto yy6;
				case '/': goto yy7;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case 'a':
				case 'b':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'o':
				case 'p':
				case 'q':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				case 'c': goto yy11;
				case 'n': goto yy12;
				case 'r': goto yy13;
				case 's': goto yy14;
				case '}': goto yy15;
				default: goto yy1;
			}
yy1:
			++YYCURSOR;
yy2:
#line 294 "txt2bin.re"
			{ goto s_err; }
#line 327 "txt2bin.cpp"
yy3:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy3;
				default: goto yy4;
			}
yy4:
#line 282 "txt2bin.re"
			{ s->tok = cursor; }
#line 340 "txt2bin.cpp"
yy5:
			++YYCURSOR;
#line 292 "txt2bin.re"
			{ s->line++; continue; }
#line 345 "txt2bin.cpp"
yy6:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy5;
				default: goto yy2;
			}
yy7:
			yych = *++YYCURSOR;
			switch (yych) {
				case '*': goto yy16;
				case '/': goto yy17;
				default: goto yy2;
			}
yy8:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
yy9:
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy10;
			}
yy10:
#line 288 "txt2bin.re"
			{ item.label1 = add_label(s->tok, cursor); goto s_1; }
#line 433 "txt2bin.cpp"
yy11:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'a': goto yy18;
				default: goto yy9;
			}
yy12:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy19;
				default: goto yy9;
			}
yy13:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'a': goto yy20;
				case 'e': goto yy21;
				default: goto yy9;
			}
yy14:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'e': goto yy22;
				default: goto yy9;
			}
yy15:
			++YYCURSOR;
#line 293 "txt2bin.re"
			{ if (s->rank == -1) goto s_err; int oldrank = s->rank; s->rank = -1; return oldrank; }
#line 463 "txt2bin.cpp"
yy16:
			++YYCURSOR;
#line 290 "txt2bin.re"
			{ goto s_24; }
#line 468 "txt2bin.cpp"
yy17:
			++YYCURSOR;
#line 289 "txt2bin.re"
			{ goto s_23; }
#line 473 "txt2bin.cpp"
yy18:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'l': goto yy23;
				default: goto yy9;
			}
yy19:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'm': goto yy24;
				default: goto yy9;
			}
yy20:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'n': goto yy25;
				default: goto yy9;
			}
yy21:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy26;
				default: goto yy9;
			}
yy22:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'n': goto yy27;
				default: goto yy9;
			}
yy23:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy28;
				default: goto yy9;
			}
yy24:
			yych = *++YYCURSOR;
			switch (yych) {
				case '_': goto yy30;
				default: goto yy9;
			}
yy25:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'k': goto yy31;
				default: goto yy9;
			}
yy26:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'v': goto yy33;
				default: goto yy9;
			}
yy27:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'd': goto yy35;
				default: goto yy9;
			}
yy28:
			yych = *++YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy29;
			}
yy29:
#line 285 "txt2bin.re"
			{ item.type = LoclOp;  goto s_3; }
#line 605 "txt2bin.cpp"
yy30:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'r': goto yy37;
				default: goto yy9;
			}
yy31:
			yych = *++YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy32;
			}
yy32:
#line 286 "txt2bin.re"
			{ goto s_20; }
#line 683 "txt2bin.cpp"
yy33:
			yych = *++YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy34;
			}
yy34:
#line 284 "txt2bin.re"
			{ item.type = RecvOp;  goto s_2; }
#line 755 "txt2bin.cpp"
yy35:
			yych = *++YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy36;
			}
yy36:
#line 283 "txt2bin.re"
			{ item.type = SendOp;  goto s_2; }
#line 827 "txt2bin.cpp"
yy37:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'a': goto yy38;
				default: goto yy9;
			}
yy38:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'n': goto yy39;
				default: goto yy9;
			}
yy39:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'k': goto yy40;
				default: goto yy9;
			}
yy40:
			yych = *++YYCURSOR;
			switch (yych) {
				case 's': goto yy41;
				default: goto yy9;
			}
yy41:
			yych = *++YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy8;
				default: goto yy42;
			}
yy42:
#line 287 "txt2bin.re"
			{ goto s_22; }
#line 923 "txt2bin.cpp"
		}
#line 295 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_1:
	state =1;

	// printf("Entered s_1\n");


#line 936 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 9) YYFILL(9);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy46;
				case ':': goto yy48;
				case 'i': goto yy49;
				case 'r': goto yy50;
				default: goto yy44;
			}
yy44:
			++YYCURSOR;
yy45:
#line 309 "txt2bin.re"
			{ goto s_err; }
#line 954 "txt2bin.cpp"
yy46:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy46;
				default: goto yy47;
			}
yy47:
#line 305 "txt2bin.re"
			{ goto s_1; }
#line 967 "txt2bin.cpp"
yy48:
			++YYCURSOR;
#line 306 "txt2bin.re"
			{ goto s_4; }
#line 972 "txt2bin.cpp"
yy49:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'r': goto yy51;
				default: goto yy45;
			}
yy50:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'e': goto yy53;
				default: goto yy45;
			}
yy51:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'e': goto yy54;
				default: goto yy52;
			}
yy52:
			YYCURSOR = YYMARKER;
			goto yy45;
yy53:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'q': goto yy55;
				default: goto yy52;
			}
yy54:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'q': goto yy56;
				default: goto yy52;
			}
yy55:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy57;
				default: goto yy52;
			}
yy56:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy58;
				default: goto yy52;
			}
yy57:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'i': goto yy59;
				default: goto yy52;
			}
yy58:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'i': goto yy60;
				default: goto yy52;
			}
yy59:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'r': goto yy61;
				default: goto yy52;
			}
yy60:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'r': goto yy62;
				default: goto yy52;
			}
yy61:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'e': goto yy63;
				default: goto yy52;
			}
yy62:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'e': goto yy64;
				default: goto yy52;
			}
yy63:
			yych = *++YYCURSOR;
			switch (yych) {
				case 's': goto yy65;
				default: goto yy52;
			}
yy64:
			yych = *++YYCURSOR;
			switch (yych) {
				case 's': goto yy66;
				default: goto yy52;
			}
yy65:
			++YYCURSOR;
#line 307 "txt2bin.re"
			{ item.type = Dependency;       goto s_5; }
#line 1070 "txt2bin.cpp"
yy66:
			++YYCURSOR;
#line 308 "txt2bin.re"
			{ item.type = StartDependency;  goto s_5; }
#line 1075 "txt2bin.cpp"
		}
#line 310 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_2:
	state=2;

	// printf("Entered s_2\n");

		s->tok = cursor;

#line 1088 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy69;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy71;
				default: goto yy68;
			}
yy68:
			++YYCURSOR;
#line 322 "txt2bin.re"
			{ goto s_err; }
#line 1112 "txt2bin.cpp"
yy69:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy69;
				default: goto yy70;
			}
yy70:
#line 320 "txt2bin.re"
			{ goto s_2; }
#line 1125 "txt2bin.cpp"
yy71:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy71;
				default: goto yy72;
			}
yy72:
#line 321 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_10; }
#line 1146 "txt2bin.cpp"
		}
#line 323 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_3:
	state = 3;
	// printf("Entered s_3\n");

		s->tok = cursor;

#line 1159 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy75;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy77;
				default: goto yy74;
			}
yy74:
			++YYCURSOR;
#line 335 "txt2bin.re"
			{ goto s_err; }
#line 1183 "txt2bin.cpp"
yy75:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy75;
				default: goto yy76;
			}
yy76:
#line 333 "txt2bin.re"
			{ goto s_3; }
#line 1196 "txt2bin.cpp"
yy77:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy77;
				default: goto yy78;
			}
yy78:
#line 334 "txt2bin.re"
			{ item.size = add_number(s->tok, cursor); goto s_7; }
#line 1217 "txt2bin.cpp"
		}
#line 336 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_4:
	state = 4;
	// printf("Entered s_4\n");


#line 1229 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy82;
				case 'c': goto yy84;
				case 'r': goto yy85;
				case 's': goto yy86;
				default: goto yy80;
			}
yy80:
			++YYCURSOR;
yy81:
#line 349 "txt2bin.re"
			{ goto s_err; }
#line 1247 "txt2bin.cpp"
yy82:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy82;
				default: goto yy83;
			}
yy83:
#line 345 "txt2bin.re"
			{ goto s_4; }
#line 1260 "txt2bin.cpp"
yy84:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'a': goto yy87;
				default: goto yy81;
			}
yy85:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'e': goto yy89;
				default: goto yy81;
			}
yy86:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'e': goto yy90;
				default: goto yy81;
			}
yy87:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'l': goto yy91;
				default: goto yy88;
			}
yy88:
			YYCURSOR = YYMARKER;
			goto yy81;
yy89:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy92;
				default: goto yy88;
			}
yy90:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'n': goto yy93;
				default: goto yy88;
			}
yy91:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy94;
				default: goto yy88;
			}
yy92:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'v': goto yy95;
				default: goto yy88;
			}
yy93:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'd': goto yy96;
				default: goto yy88;
			}
yy94:
			++YYCURSOR;
#line 346 "txt2bin.re"
			{ item.type = LoclOp; goto s_3; }
#line 1322 "txt2bin.cpp"
yy95:
			++YYCURSOR;
#line 348 "txt2bin.re"
			{ item.type = RecvOp; goto s_2; }
#line 1327 "txt2bin.cpp"
yy96:
			++YYCURSOR;
#line 347 "txt2bin.re"
			{ item.type = SendOp; goto s_2; }
#line 1332 "txt2bin.cpp"
		}
#line 350 "txt2bin.re"

	assert(0==1); //We should never reach this line

s_5:
	state =5;
	// printf("Entered s_5\n");

		s->tok = cursor;

#line 1344 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy99;
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy101;
				default: goto yy98;
			}
yy98:
			++YYCURSOR;
#line 361 "txt2bin.re"
			{ goto s_err; }
#line 1410 "txt2bin.cpp"
yy99:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy99;
				default: goto yy100;
			}
yy100:
#line 359 "txt2bin.re"
			{ goto s_5; }
#line 1423 "txt2bin.cpp"
yy101:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9':
				case 'A':
				case 'B':
				case 'C':
				case 'D':
				case 'E':
				case 'F':
				case 'G':
				case 'H':
				case 'I':
				case 'J':
				case 'K':
				case 'L':
				case 'M':
				case 'N':
				case 'O':
				case 'P':
				case 'Q':
				case 'R':
				case 'S':
				case 'T':
				case 'U':
				case 'V':
				case 'W':
				case 'X':
				case 'Y':
				case 'Z':
				case '_':
				case 'a':
				case 'b':
				case 'c':
				case 'd':
				case 'e':
				case 'f':
				case 'g':
				case 'h':
				case 'i':
				case 'j':
				case 'k':
				case 'l':
				case 'm':
				case 'n':
				case 'o':
				case 'p':
				case 'q':
				case 'r':
				case 's':
				case 't':
				case 'u':
				case 'v':
				case 'w':
				case 'x':
				case 'y':
				case 'z': goto yy101;
				default: goto yy102;
			}
yy102:
#line 360 "txt2bin.re"
			{ item.label2 = add_label(s->tok, cursor); goto s_6; }
#line 1497 "txt2bin.cpp"
		}
#line 362 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_6:
	state = 6;
	// printf("Entered s_6\n");


#line 1509 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy106;
				case '\n': goto yy108;
				case '\r': goto yy109;
				default: goto yy104;
			}
yy104:
			++YYCURSOR;
yy105:
#line 373 "txt2bin.re"
			{ goto s_err; }
#line 1526 "txt2bin.cpp"
yy106:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy106;
				default: goto yy107;
			}
yy107:
#line 371 "txt2bin.re"
			{ goto s_6; }
#line 1539 "txt2bin.cpp"
yy108:
			++YYCURSOR;
#line 372 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1544 "txt2bin.cpp"
yy109:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy108;
				default: goto yy105;
			}
		}
#line 374 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_7:
	state = 7;
	// printf("Entered s_7\n");


#line 1562 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy113;
				case '\n': goto yy115;
				case '\r': goto yy116;
				case 'c': goto yy117;
				default: goto yy111;
			}
yy111:
			++YYCURSOR;
yy112:
#line 386 "txt2bin.re"
			{ goto s_err; }
#line 1580 "txt2bin.cpp"
yy113:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy113;
				default: goto yy114;
			}
yy114:
#line 383 "txt2bin.re"
			{ goto s_7; }
#line 1593 "txt2bin.cpp"
yy115:
			++YYCURSOR;
#line 385 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1598 "txt2bin.cpp"
yy116:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy115;
				default: goto yy112;
			}
yy117:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'p': goto yy118;
				default: goto yy112;
			}
yy118:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy120;
				default: goto yy119;
			}
yy119:
			YYCURSOR = YYMARKER;
			goto yy112;
yy120:
			++YYCURSOR;
#line 384 "txt2bin.re"
			{ goto s_8; }
#line 1624 "txt2bin.cpp"
		}
#line 387 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_8:
	state =8;
	// printf("Entered s_8\n");
	
	s->tok = cursor;


#line 1638 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy123;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy125;
				default: goto yy122;
			}
yy122:
			++YYCURSOR;
#line 400 "txt2bin.re"
			{ goto s_err; }
#line 1662 "txt2bin.cpp"
yy123:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy123;
				default: goto yy124;
			}
yy124:
#line 398 "txt2bin.re"
			{ goto s_8; }
#line 1675 "txt2bin.cpp"
yy125:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy125;
				default: goto yy126;
			}
yy126:
#line 399 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_9; }
#line 1696 "txt2bin.cpp"
		}
#line 401 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_9:
	state=9;
	// printf("Entered s_9\n");


#line 1708 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy130;
				case '\n': goto yy132;
				case '\r': goto yy133;
				default: goto yy128;
			}
yy128:
			++YYCURSOR;
yy129:
#line 412 "txt2bin.re"
			{ goto s_err; }
#line 1725 "txt2bin.cpp"
yy130:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy130;
				default: goto yy131;
			}
yy131:
#line 410 "txt2bin.re"
			{ goto s_9; }
#line 1738 "txt2bin.cpp"
yy132:
			++YYCURSOR;
#line 411 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 1743 "txt2bin.cpp"
yy133:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy132;
				default: goto yy129;
			}
		}
#line 413 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_10:
	state=10;
	// printf("Entered s_10\n");


#line 1761 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy136;
				case 'b': goto yy138;
				default: goto yy135;
			}
yy135:
			++YYCURSOR;
#line 424 "txt2bin.re"
			{ goto s_err; }
#line 1776 "txt2bin.cpp"
yy136:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy136;
				default: goto yy137;
			}
yy137:
#line 422 "txt2bin.re"
			{ goto s_10; }
#line 1789 "txt2bin.cpp"
yy138:
			++YYCURSOR;
#line 423 "txt2bin.re"
			{ goto s_11; }
#line 1794 "txt2bin.cpp"
		}
#line 425 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_11:
	state = 11;
	// printf("Entered s_11\n");


#line 1806 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy142;
				case 'f': goto yy144;
				case 't': goto yy145;
				default: goto yy140;
			}
yy140:
			++YYCURSOR;
yy141:
#line 437 "txt2bin.re"
			{ goto s_err; }
#line 1823 "txt2bin.cpp"
yy142:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy142;
				default: goto yy143;
			}
yy143:
#line 434 "txt2bin.re"
			{ goto s_11; }
#line 1836 "txt2bin.cpp"
yy144:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'r': goto yy146;
				default: goto yy141;
			}
yy145:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'o': goto yy148;
				default: goto yy141;
			}
yy146:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'o': goto yy149;
				default: goto yy147;
			}
yy147:
			YYCURSOR = YYMARKER;
			goto yy141;
yy148:
			++YYCURSOR;
#line 435 "txt2bin.re"
			{ if (item.type == SendOp) {goto s_12;} else {goto s_err;}; }
#line 1862 "txt2bin.cpp"
yy149:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'm': goto yy150;
				default: goto yy147;
			}
yy150:
			++YYCURSOR;
#line 436 "txt2bin.re"
			{ if (item.type == RecvOp) {goto s_12;} else {goto s_err;}; }
#line 1873 "txt2bin.cpp"
		}
#line 438 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_12:
	state = 12;	
	// printf("Entered s_12\n");
	
	s->tok = cursor;


#line 1887 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy154;
				case '-': goto yy156;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy157;
				default: goto yy152;
			}
yy152:
			++YYCURSOR;
yy153:
#line 452 "txt2bin.re"
			{ goto s_err; }
#line 1913 "txt2bin.cpp"
yy154:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy154;
				default: goto yy155;
			}
yy155:
#line 449 "txt2bin.re"
			{ goto s_12; }
#line 1926 "txt2bin.cpp"
yy156:
			yych = *++YYCURSOR;
			switch (yych) {
				case '1': goto yy159;
				default: goto yy153;
			}
yy157:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy157;
				default: goto yy158;
			}
yy158:
#line 451 "txt2bin.re"
			{ item.target = add_number(s->tok, cursor); goto s_13; }
#line 1953 "txt2bin.cpp"
yy159:
			++YYCURSOR;
#line 450 "txt2bin.re"
			{if (item.type == RecvOp) {item.target = std::numeric_limits<uint32_t>::max(); goto s_13;} else {goto s_err;}; }
#line 1958 "txt2bin.cpp"
		}
#line 453 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_13:
	state = 13;
	// printf("Entered s_13\n");


#line 1970 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy163;
				case '\n': goto yy165;
				case '\r': goto yy166;
				case 'c': goto yy167;
				case 'n': goto yy168;
				case 't': goto yy169;
				default: goto yy161;
			}
yy161:
			++YYCURSOR;
yy162:
#line 467 "txt2bin.re"
			{ goto s_err; }
#line 1990 "txt2bin.cpp"
yy163:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy163;
				default: goto yy164;
			}
yy164:
#line 462 "txt2bin.re"
			{ goto s_13; }
#line 2003 "txt2bin.cpp"
yy165:
			++YYCURSOR;
#line 466 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2008 "txt2bin.cpp"
yy166:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy165;
				default: goto yy162;
			}
yy167:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'p': goto yy170;
				default: goto yy162;
			}
yy168:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'i': goto yy172;
				default: goto yy162;
			}
yy169:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'a': goto yy173;
				default: goto yy162;
			}
yy170:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy174;
				default: goto yy171;
			}
yy171:
			YYCURSOR = YYMARKER;
			goto yy162;
yy172:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy175;
				default: goto yy171;
			}
yy173:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'g': goto yy176;
				default: goto yy171;
			}
yy174:
			++YYCURSOR;
#line 464 "txt2bin.re"
			{ goto s_16; }
#line 2058 "txt2bin.cpp"
yy175:
			++YYCURSOR;
#line 465 "txt2bin.re"
			{ goto s_18; }
#line 2063 "txt2bin.cpp"
yy176:
			++YYCURSOR;
#line 463 "txt2bin.re"
			{ goto s_14; }
#line 2068 "txt2bin.cpp"
		}
#line 468 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_14:
	state = 14;
	// printf("Entered s_14\n");

	s->tok = cursor;


#line 2082 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy180;
				case '-': goto yy182;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy183;
				default: goto yy178;
			}
yy178:
			++YYCURSOR;
yy179:
#line 482 "txt2bin.re"
			{ goto s_err; }
#line 2108 "txt2bin.cpp"
yy180:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy180;
				default: goto yy181;
			}
yy181:
#line 479 "txt2bin.re"
			{ goto s_14; }
#line 2121 "txt2bin.cpp"
yy182:
			yych = *++YYCURSOR;
			switch (yych) {
				case '1': goto yy185;
				default: goto yy179;
			}
yy183:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy183;
				default: goto yy184;
			}
yy184:
#line 481 "txt2bin.re"
			{ item.tag = add_number(s->tok, cursor); goto s_15; }
#line 2148 "txt2bin.cpp"
yy185:
			++YYCURSOR;
#line 480 "txt2bin.re"
			{ item.tag = std::numeric_limits<uint32_t>::max(); goto s_15; }
#line 2153 "txt2bin.cpp"
		}
#line 483 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_15:
	state =15;
	// printf("Entered s_15\n");


#line 2165 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy189;
				case '\n': goto yy191;
				case '\r': goto yy192;
				case 'c': goto yy193;
				case 'n': goto yy194;
				default: goto yy187;
			}
yy187:
			++YYCURSOR;
yy188:
#line 496 "txt2bin.re"
			{ goto s_err; }
#line 2184 "txt2bin.cpp"
yy189:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy189;
				default: goto yy190;
			}
yy190:
#line 492 "txt2bin.re"
			{ goto s_15; }
#line 2197 "txt2bin.cpp"
yy191:
			++YYCURSOR;
#line 495 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2202 "txt2bin.cpp"
yy192:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy191;
				default: goto yy188;
			}
yy193:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'p': goto yy195;
				default: goto yy188;
			}
yy194:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'i': goto yy197;
				default: goto yy188;
			}
yy195:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'u': goto yy198;
				default: goto yy196;
			}
yy196:
			YYCURSOR = YYMARKER;
			goto yy188;
yy197:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy199;
				default: goto yy196;
			}
yy198:
			++YYCURSOR;
#line 493 "txt2bin.re"
			{ goto s_16; }
#line 2240 "txt2bin.cpp"
yy199:
			++YYCURSOR;
#line 494 "txt2bin.re"
			{ goto s_18; }
#line 2245 "txt2bin.cpp"
		}
#line 497 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_16:
	state = 16;
	// printf("Entered s_16\n");
	
	s->tok = cursor;


#line 2259 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy202;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy204;
				default: goto yy201;
			}
yy201:
			++YYCURSOR;
#line 510 "txt2bin.re"
			{ goto s_err; }
#line 2283 "txt2bin.cpp"
yy202:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy202;
				default: goto yy203;
			}
yy203:
#line 508 "txt2bin.re"
			{ goto s_16; }
#line 2296 "txt2bin.cpp"
yy204:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy204;
				default: goto yy205;
			}
yy205:
#line 509 "txt2bin.re"
			{ item.cpu = add_number(s->tok, cursor); goto s_17; }
#line 2317 "txt2bin.cpp"
		}
#line 511 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_17:
	state = 17;
	// printf("Entered s_17\n");
	

#line 2329 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy209;
				case '\n': goto yy211;
				case '\r': goto yy212;
				case 'n': goto yy213;
				default: goto yy207;
			}
yy207:
			++YYCURSOR;
yy208:
#line 523 "txt2bin.re"
			{ goto s_err; }
#line 2347 "txt2bin.cpp"
yy209:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy209;
				default: goto yy210;
			}
yy210:
#line 520 "txt2bin.re"
			{ goto s_17; }
#line 2360 "txt2bin.cpp"
yy211:
			++YYCURSOR;
#line 522 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2365 "txt2bin.cpp"
yy212:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy211;
				default: goto yy208;
			}
yy213:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
				case 'i': goto yy214;
				default: goto yy208;
			}
yy214:
			yych = *++YYCURSOR;
			switch (yych) {
				case 'c': goto yy216;
				default: goto yy215;
			}
yy215:
			YYCURSOR = YYMARKER;
			goto yy208;
yy216:
			++YYCURSOR;
#line 521 "txt2bin.re"
			{ goto s_18; }
#line 2391 "txt2bin.cpp"
		}
#line 524 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_18:
	state = 18;
	// printf("Entered s_18\n");
	
	s->tok = cursor;


#line 2405 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy219;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy221;
				default: goto yy218;
			}
yy218:
			++YYCURSOR;
#line 537 "txt2bin.re"
			{ goto s_err; }
#line 2429 "txt2bin.cpp"
yy219:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy219;
				default: goto yy220;
			}
yy220:
#line 535 "txt2bin.re"
			{ goto s_18; }
#line 2442 "txt2bin.cpp"
yy221:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy221;
				default: goto yy222;
			}
yy222:
#line 536 "txt2bin.re"
			{ item.nic = add_number(s->tok, cursor); goto s_19; }
#line 2463 "txt2bin.cpp"
		}
#line 538 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_19:
	state = 19;
	// printf("Entered s_19\n");


#line 2475 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy226;
				case '\n': goto yy228;
				case '\r': goto yy229;
				default: goto yy224;
			}
yy224:
			++YYCURSOR;
yy225:
#line 549 "txt2bin.re"
			{ goto s_err; }
#line 2492 "txt2bin.cpp"
yy226:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy226;
				default: goto yy227;
			}
yy227:
#line 547 "txt2bin.re"
			{ goto s_19; }
#line 2505 "txt2bin.cpp"
yy228:
			++YYCURSOR;
#line 548 "txt2bin.re"
			{ s->line++; process_item(s, &item); continue; }
#line 2510 "txt2bin.cpp"
yy229:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy228;
				default: goto yy225;
			}
		}
#line 550 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_20:
	state = 20;
	// printf("Entered s_20\n");

	s->tok = cursor;


#line 2530 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy232;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy234;
				default: goto yy231;
			}
yy231:
			++YYCURSOR;
#line 563 "txt2bin.re"
			{ goto s_err; }
#line 2554 "txt2bin.cpp"
yy232:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy232;
				default: goto yy233;
			}
yy233:
#line 561 "txt2bin.re"
			{ goto s_20; }
#line 2567 "txt2bin.cpp"
yy234:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy234;
				default: goto yy235;
			}
yy235:
#line 562 "txt2bin.re"
			{ s->rank = add_number(s->tok, cursor); s->curr_rank = s->rank; goto s_21; }
#line 2588 "txt2bin.cpp"
		}
#line 564 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_21:
	state = 21;
	// printf("Entered s_21\n");


#line 2600 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy238;
				case '{': goto yy240;
				default: goto yy237;
			}
yy237:
			++YYCURSOR;
#line 575 "txt2bin.re"
			{ goto s_err; }
#line 2615 "txt2bin.cpp"
yy238:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy238;
				default: goto yy239;
			}
yy239:
#line 573 "txt2bin.re"
			{ goto s_21; }
#line 2628 "txt2bin.cpp"
yy240:
			++YYCURSOR;
#line 574 "txt2bin.re"
			{ goto s_0; }
#line 2633 "txt2bin.cpp"
		}
#line 576 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_22:
	state = 22;
	// printf("Entered s_22\n");

	s->tok = cursor;


#line 2647 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy243;
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy245;
				default: goto yy242;
			}
yy242:
			++YYCURSOR;
#line 589 "txt2bin.re"
			{ goto s_err; }
#line 2671 "txt2bin.cpp"
yy243:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '\t':
				case ' ': goto yy243;
				default: goto yy244;
			}
yy244:
#line 587 "txt2bin.re"
			{ goto s_22; }
#line 2684 "txt2bin.cpp"
yy245:
			++YYCURSOR;
			if (YYLIMIT <= YYCURSOR) YYFILL(1);
			yych = *YYCURSOR;
			switch (yych) {
				case '0':
				case '1':
				case '2':
				case '3':
				case '4':
				case '5':
				case '6':
				case '7':
				case '8':
				case '9': goto yy245;
				default: goto yy246;
			}
yy246:
#line 588 "txt2bin.re"
			{ s->num_ranks = add_number(s->tok, cursor); goto s_0; }
#line 2705 "txt2bin.cpp"
		}
#line 590 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_23:
	state = 23;
	// printf("Entered s_23\n");


#line 2717 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\n': goto yy250;
				case '\r': goto yy251;
				default: goto yy248;
			}
yy248:
			++YYCURSOR;
yy249:
#line 600 "txt2bin.re"
			{ goto s_23; }
#line 2732 "txt2bin.cpp"
yy250:
			++YYCURSOR;
#line 599 "txt2bin.re"
			{ s->line++; continue;  }
#line 2737 "txt2bin.cpp"
yy251:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy250;
				default: goto yy249;
			}
		}
#line 601 "txt2bin.re"


	assert(0==1); //We should never reach this line

s_24:
	state = 24;
	// printf("Entered s_24\n");


#line 2755 "txt2bin.cpp"
		{
			YYCTYPE yych;
			if ((YYLIMIT - YYCURSOR) < 2) YYFILL(2);
			yych = *YYCURSOR;
			switch (yych) {
				case '\n': goto yy255;
				case '\r': goto yy256;
				case '*': goto yy257;
				default: goto yy253;
			}
yy253:
			++YYCURSOR;
yy254:
#line 612 "txt2bin.re"
			{ goto s_24; }
#line 2771 "txt2bin.cpp"
yy255:
			++YYCURSOR;
#line 611 "txt2bin.re"
			{ s->line++; goto s_24;  }
#line 2776 "txt2bin.cpp"
yy256:
			yych = *++YYCURSOR;
			switch (yych) {
				case '\n': goto yy255;
				default: goto yy254;
			}
yy257:
			yych = *++YYCURSOR;
			switch (yych) {
				case '/': goto yy258;
				default: goto yy254;
			}
yy258:
			++YYCURSOR;
#line 610 "txt2bin.re"
			{ continue; }
#line 2793 "txt2bin.cpp"
		}
#line 613 "txt2bin.re"


	assert(0==1); //We should never reach this line
	
s_err:

	fprintf(stderr, "Error in line %i:\n", s->line);
	
	uchar* nlbef = s->bot;
	uchar* nlaft = s->lim;
	// find the last newline before the error
	uchar* c = cursor-2;
	while (c>s->bot) {
		c--;
		if (*c == '\n') {
			nlbef = c;
			break;
		}
	}
	// find the next newline after the error
	c = cursor-2;
	while (c<s->lim) {
		c++;
		if (*c == '\n') {
			nlaft = c;
			break;
		}
	}

	for (uchar* c = nlbef+1; c<nlaft; c++) {
		fprintf(stderr, "%c", *c);
	}
	fprintf(stderr, "\n");

	for (int cnt=0; cnt<(cursor-2)-nlbef; cnt++) {
		fprintf(stderr, " ");
	}
	fprintf(stderr, "^\n");


	switch(state) {
		case 0:
			fprintf(stderr,"Expected: \"rank\", \"num_ranks\", \"calc\", \"send\", \"recv\", an identifier, \"}\" or \"\\n\"\n");
			break;
		case 1:
			fprintf(stderr,"Expected: \":\", \"requires\" or \"irequires\"\n");
			break;
		case 2:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 3:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 4:
			fprintf(stderr,"Expected: \"calc\", \"send\" or \"recv\"\n");
			break;
		case 5:
			fprintf(stderr,"Expected: an identifier\n");
			break;
		case 6:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 7:
			fprintf(stderr,"Expected: \"cpu\" or \"\\n\"\n");
			break;
		case 8:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 9:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 10:
			fprintf(stderr,"Expected: \"b\"\n");
			break;
		case 11:
			if (item.type == SendOp) fprintf(stderr,"Expected: \"to\"\n");
			else if (item.type == RecvOp) fprintf(stderr,"Expected: \"from\"\n");
			else fprintf(stderr,"Expected: \"to\" or \"from\"\n");
			break;
		case 12:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 13:
			fprintf(stderr,"Expected: \"tag\", \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 14:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 15:
			fprintf(stderr,"Expected: \"cpu\", \"nic\" or \"\\n\"\n");
			break;
		case 16:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 17:
			fprintf(stderr,"Expected: \"nic\" or \"\\n\"\n");
			break;
		case 18:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 19:
			fprintf(stderr,"Expected: \"\\n\"\n");
			break;
		case 20:
			fprintf(stderr,"Expected: an integer\n");
			break;
		case 21:
			fprintf(stderr,"Expected: \"{\"\n");
			break;
		case 22:
			fprintf(stderr,"Expected: an integer\n");
			break;
	}
	
	if (*(cursor-1) == '\n') {
		fprintf(stderr, "Instead the schedule contained: \"\\n\"\n");
	}
	else {
		fprintf(stderr, "Instead the schedule contained: \"%c\"\n", *(cursor-1));
	}


	
	exit(EXIT_FAILURE);

}
}

int main(int argc, char **argv){
    
	Scanner in;
	int lastprogress = 0;

	if (cmdline_parser(argc, argv, &args_info) != 0) {
		fprintf(stderr, "Couldn't parse command line arguments!\n");
		exit(EXIT_FAILURE);
	}

    memset((char*) &in, 0, sizeof(in));
   	in.fd = fopen(args_info.input_arg, "r");
	if (in.fd == NULL) {
		fprintf(stderr, "Couldn't open input file %s!\n", args_info.input_arg);
		exit(EXIT_FAILURE);
	}
	in.idtbl = new std::map<std::string, goalop_t>;
    
	uint32_t numranks = -1;

	while (true) {
		
		in.schedule = new Goal;
		
		scan(&in);

		if (in.num_ranks < 1) {
			fprintf(stderr, "Parse error: Number of Ranks undefined\n");
			exit(EXIT_FAILURE);
		}

		in.idtbl->clear();

		in.schedule->SetRank(in.curr_rank);
		in.schedule->SetNumRanks(in.num_ranks);
		in.schedule->SerializeSchedule(args_info.output_arg);
		delete in.schedule;
		int newprogress = round((((double) in.curr_rank) / in.num_ranks)*100);
		if (args_info.progress_given && (newprogress > lastprogress) ) {
			lastprogress = newprogress;
			printf("Progress %i%% - parsed schedule %i/%i\n", lastprogress, in.curr_rank, in.num_ranks);
		}
		if (in.curr_rank+1 == in.num_ranks) break;
	}
	
	free(in.bot);
	exit(EXIT_SUCCESS);
}
